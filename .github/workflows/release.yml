name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Validate release
  validate-release:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            IS_PRERELEASE="${{ github.event.inputs.prerelease }}"
          else
            VERSION="${{ github.ref_name }}"
            # Check if version contains pre-release identifiers
            if [[ "$VERSION" =~ (alpha|beta|rc|pre) ]]; then
              IS_PRERELEASE="true"
            else
              IS_PRERELEASE="false"
            fi
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is-prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          
          echo "Release version: $VERSION"
          echo "Is pre-release: $IS_PRERELEASE"

      - name: Validate version format
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+([a-zA-Z0-9\-\.]+)?$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected format: v1.2.3 or v1.2.3-alpha.1"
            exit 1
          fi
          echo "âœ… Version format is valid"

      - name: Check if tag exists
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if git tag | grep -q "^$VERSION$"; then
            echo "âŒ Tag $VERSION already exists"
            exit 1
          fi
          echo "âœ… Tag $VERSION is available"

  # Run comprehensive tests before release
  release-tests:
    name: Release Tests
    runs-on: ubuntu-latest
    needs: validate-release
    strategy:
      fail-fast: true
      matrix:
        test-type: [smoke, api, ui, integration]
        browser: [chromium, firefox, webkit]
        exclude:
          - test-type: api
            browser: firefox
          - test-type: api
            browser: webkit
          - test-type: smoke
            browser: firefox
          - test-type: smoke
            browser: webkit
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build release image
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          tags: release-tests:latest
          cache-from: type=gha

      - name: Run release tests
        run: |
          docker run --rm \
            -e HEADLESS=true \
            -e PLAYWRIGHT_BROWSER=${{ matrix.browser }} \
            -e TEST_ENV=release \
            -v ${{ github.workspace }}/test-results:/app/test-results \
            release-tests:latest \
            python -m pytest -m ${{ matrix.test-type }} --tb=short -v \
            --junitxml=test-results/junit-release-${{ matrix.test-type }}-${{ matrix.browser }}.xml

      - name: Upload release test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: release-test-results-${{ matrix.test-type }}-${{ matrix.browser }}
          path: test-results/
          retention-days: 30

  # Build and push release images
  build-release:
    name: Build Release Images
    runs-on: ubuntu-latest
    needs: [validate-release, release-tests]
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.validate-release.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.validate-release.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.validate-release.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          annotations: |
            index:org.opencontainers.image.title=Python Playwright MCP Testing Framework
            index:org.opencontainers.image.description=Comprehensive testing framework using Playwright with MCP integration
            index:org.opencontainers.image.version=${{ needs.validate-release.outputs.version }}

  # Generate release notes
  generate-changelog:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    needs: validate-release
    outputs:
      release-notes: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ needs.validate-release.outputs.version }}"
          
          # Get previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          echo "## What's Changed" > changelog.md
          echo "" >> changelog.md
          
          if [[ -n "$PREVIOUS_TAG" ]]; then
            echo "### ðŸš€ Features" >> changelog.md
            git log --oneline --grep="^feat" --grep="^feature" $PREVIOUS_TAG..HEAD | sed 's/^/- /' >> changelog.md || true
            echo "" >> changelog.md
            
            echo "### ðŸ› Bug Fixes" >> changelog.md
            git log --oneline --grep="^fix" $PREVIOUS_TAG..HEAD | sed 's/^/- /' >> changelog.md || true
            echo "" >> changelog.md
            
            echo "### ðŸ“š Documentation" >> changelog.md
            git log --oneline --grep="^docs" $PREVIOUS_TAG..HEAD | sed 's/^/- /' >> changelog.md || true
            echo "" >> changelog.md
            
            echo "### ðŸ”§ Maintenance" >> changelog.md
            git log --oneline --grep="^chore" --grep="^refactor" --grep="^style" $PREVIOUS_TAG..HEAD | sed 's/^/- /' >> changelog.md || true
            echo "" >> changelog.md
            
            echo "### ðŸ§ª Testing" >> changelog.md
            git log --oneline --grep="^test" $PREVIOUS_TAG..HEAD | sed 's/^/- /' >> changelog.md || true
            echo "" >> changelog.md
            
            echo "### Other Changes" >> changelog.md
            git log --oneline --invert-grep --grep="^feat" --grep="^fix" --grep="^docs" --grep="^chore" --grep="^refactor" --grep="^style" --grep="^test" $PREVIOUS_TAG..HEAD | sed 's/^/- /' >> changelog.md || true
          else
            echo "Initial release" >> changelog.md
          fi
          
          # Add Docker image info
          echo "" >> changelog.md
          echo "## ðŸ“¦ Docker Images" >> changelog.md
          echo "" >> changelog.md
          echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}\`" >> changelog.md
          echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`" >> changelog.md
          echo "" >> changelog.md
          
          # Add usage instructions
          echo "## ðŸš€ Quick Start" >> changelog.md
          echo "" >> changelog.md
          echo "\`\`\`bash" >> changelog.md
          echo "# Clone repository" >> changelog.md
          echo "git clone https://github.com/${{ github.repository }}.git" >> changelog.md
          echo "cd \$(basename ${{ github.repository }})" >> changelog.md
          echo "" >> changelog.md
          echo "# Setup and run tests" >> changelog.md
          echo "./scripts/setup.sh" >> changelog.md
          echo "./scripts/run-tests.sh" >> changelog.md
          echo "" >> changelog.md
          echo "# Or use Docker" >> changelog.md
          echo "docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}" >> changelog.md
          echo "\`\`\`" >> changelog.md
          
          # Output for GitHub Actions
          CHANGELOG_CONTENT=$(cat changelog.md)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload changelog
        uses: actions/upload-artifact@v4
        with:
          name: release-changelog
          path: changelog.md
          retention-days: 90

  # Create GitHub release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-release, build-release, generate-changelog]
    outputs:
      release-id: ${{ steps.release.outputs.id }}
      release-url: ${{ steps.release.outputs.html_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create/update tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ needs.validate-release.outputs.version }}"
          git tag $VERSION
          git push origin $VERSION

      - name: Create release
        id: release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.validate-release.outputs.version }}
          release_name: Release ${{ needs.validate-release.outputs.version }}
          body: ${{ needs.generate-changelog.outputs.release-notes }}
          draft: false
          prerelease: ${{ needs.validate-release.outputs.is-prerelease }}

      - name: Upload test results to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.release.outputs.upload_url }}
          asset_path: ./test-results.zip
          asset_name: test-results-${{ needs.validate-release.outputs.version }}.zip
          asset_content_type: application/zip
        continue-on-error: true

  # Security scan of release
  security-scan:
    name: Security Scan Release
    runs-on: ubuntu-latest
    needs: [validate-release, build-release]
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Upload security scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results
          path: trivy-results.sarif
          retention-days: 90

  # Deployment to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [create-release, security-scan]
    if: needs.validate-release.outputs.is-prerelease == 'false'
    environment:
      name: staging
      url: https://staging.example.com
    steps:
      - name: Deploy to staging
        run: |
          echo "ðŸš€ Deploying ${{ needs.validate-release.outputs.version }} to staging..."
          # Add your deployment commands here
          echo "âœ… Successfully deployed to staging!"

      - name: Run staging smoke tests
        run: |
          echo "ðŸ§ª Running staging smoke tests..."
          # Add staging test commands here
          echo "âœ… Staging tests passed!"

  # Production deployment approval
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging, validate-release]
    if: needs.validate-release.outputs.is-prerelease == 'false'
    environment:
      name: production
      url: https://example.com
    steps:
      - name: Deploy to production
        run: |
          echo "ðŸš€ Deploying ${{ needs.validate-release.outputs.version }} to production..."
          # Add your production deployment commands here
          echo "âœ… Successfully deployed to production!"

      - name: Run production health checks
        run: |
          echo "ðŸ¥ Running production health checks..."
          # Add health check commands here
          echo "âœ… Production health checks passed!"

  # Notification and cleanup
  notify-release:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [create-release, deploy-production]
    if: always()
    steps:
      - name: Generate release summary
        run: |
          echo "## ðŸŽ‰ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ needs.validate-release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Type**: $(if [[ "${{ needs.validate-release.outputs.is-prerelease }}" == "true" ]]; then echo "Pre-release"; else echo "Stable"; fi)" >> $GITHUB_STEP_SUMMARY
          echo "**Release**: [${{ needs.validate-release.outputs.version }}](${{ needs.create-release.outputs.release-url }})" >> $GITHUB_STEP_SUMMARY
          echo "**Docker**: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "ðŸš€ **Deployment**: Successfully deployed to production" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.validate-release.outputs.is-prerelease }}" == "true" ]]; then
            echo "ðŸš§ **Deployment**: Pre-release, not deployed to production" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Deployment**: Failed to deploy to production" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create issue for failed release
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = `ðŸš¨ Release ${{ needs.validate-release.outputs.version }} Failed`;
            const body = `## Release Failure Report
            
            **Version**: ${{ needs.validate-release.outputs.version }}
            **Workflow**: [Release workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            **Trigger**: ${{ github.event_name }}
            
            ### Failed Jobs
            - Code Quality: ${{ needs.validate-release.result }}
            - Release Tests: ${{ needs.release-tests.result }}
            - Build Release: ${{ needs.build-release.result }}
            - Create Release: ${{ needs.create-release.result }}
            - Security Scan: ${{ needs.security-scan.result }}
            - Deploy Staging: ${{ needs.deploy-staging.result }}
            - Deploy Production: ${{ needs.deploy-production.result }}
            
            ### Next Steps
            1. Review failed workflow logs
            2. Fix identified issues
            3. Re-run release process
            4. Close this issue when resolved
            
            /cc @${{ github.actor }}`;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['bug', 'release', 'urgent']
            });